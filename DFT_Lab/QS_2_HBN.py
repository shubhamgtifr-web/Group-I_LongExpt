# -*- coding: utf-8 -*-
"""DFT2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ax-LCV2qwF9vhytP_F3Z6RWvnkVGXIyZ
"""

from google.colab import files

uploaded = files.upload()

import numpy as np
import matplotlib.pyplot as plt
from pathlib import Path

fer=1.3450

HR_FILE = Path("BN_hr.dat")
POSCAR = Path("POSCAR_BN.txt")

GAMMA = np.array([0.0, 0.0, 0.0])
A_pt   = np.array([0.0, 0.0, 0.5])
H_pt   = np.array([1.0/3.0, 1.0/3.0, 0.5])
K_pt   = np.array([1.0/3.0, 1.0/3.0, 0.0])
L_pt   = np.array([0.5, 0.0, 0.5])
M_pt   = np.array([0.5, 0.0, 0.0])
path_points = [GAMMA, M_pt, K_pt, GAMMA, A_pt, L_pt, H_pt, A_pt, L_pt, M_pt, H_pt, K_pt]
labels_seq = [r'$\Gamma$', 'M', 'K', r'$\Gamma$', 'A', 'L', 'H', 'A', 'L', 'M', 'H', 'K']


def read_poscar(poscar_path):
    p = Path(poscar_path)
    with p.open() as f:
        lines = [ln.rstrip() for ln in f.readlines() if ln.strip() != ""]
    scale = float(lines[1].split()[0])
    a1 = np.array([float(x) for x in lines[2].split()]) * scale
    a2 = np.array([float(x) for x in lines[3].split()]) * scale
    a3 = np.array([float(x) for x in lines[4].split()]) * scale
    A = np.vstack([a1, a2, a3]).T
    return A

def read_hr_file(hr_path):
    p = Path(hr_path)
    with p.open() as f:
        lines = [ln.rstrip() for ln in f.readlines()]
    idx = 1
    num_wann = int(lines[idx].strip()); idx += 1
    nrpts = int(lines[idx].strip()); idx += 1
    degs = []
    while len(degs) < nrpts:
        parts = lines[idx].split()
        degs += [int(x) for x in parts]
        idx += 1
    degs = np.array(degs, dtype=int)
    expected = num_wann * num_wann * nrpts
    H_R = {}
    for _ in range(expected):
        parts = lines[idx].split(); idx += 1
        Rx, Ry, Rz = int(parts[0]), int(parts[1]), int(parts[2])
        m = int(parts[3]) - 1
        n = int(parts[4]) - 1
        re = float(parts[5]); im = float(parts[6])
        key = (Rx, Ry, Rz)
        if key not in H_R:
            H_R[key] = np.zeros((num_wann, num_wann), dtype=np.complex128)
        H_R[key][m, n] = re + 1j*im
    R_keys = list(H_R.keys())
    if len(R_keys) != nrpts:
        print(f"Warning: nrpts={nrpts} but found {len(R_keys)} distinct R keys.")
    deg_map = {R_keys[i]: int(degs[i]) for i in range(min(len(R_keys), len(degs)))}
    return num_wann, R_keys, H_R, deg_map

def H_of_k(k_frac, num_wann, R_keys, H_R, deg_map):
    Hk = np.zeros((num_wann, num_wann), dtype=np.complex128)
    for R in R_keys:
        Rvec = np.array(R)
        phase = np.exp(1j * 2.0 * np.pi * np.dot(k_frac, Rvec))
        mult = deg_map.get(R, 1)
        Hk +=  H_R[R] * phase / mult
    Hk = 0.5*(Hk + Hk.conj().T)
    return Hk

def main():
    A = read_poscar(POSCAR)
    num_wann, R_keys, H_R_dict, deg_map = read_hr_file(HR_FILE)
    bvecs = 2.0 * np.pi * np.linalg.inv(A).T

    points_per_segment = 101
    klist_frac = []
    label_positions = []
    for i, (start, end) in enumerate(zip(path_points[:-1], path_points[1:])):
        endpoint = (i == len(path_points)-2)
        seg = [ start*(1-t) + end*t for t in np.linspace(0, 1, points_per_segment, endpoint=endpoint) ]
        label_positions.append(len(klist_frac))
        klist_frac.extend(seg)
    label_positions.append(len(klist_frac)-1)

    k_cart = [bvecs.dot(kf) for kf in klist_frac]
    kdist = np.zeros(len(k_cart))
    for i in range(1, len(k_cart)):
        kdist[i] = kdist[i-1] + np.linalg.norm(k_cart[i] - k_cart[i-1])

    eigs = np.zeros((len(klist_frac), num_wann))
    for i, kf in enumerate(klist_frac):
        Hk = H_of_k(kf, num_wann, R_keys, H_R_dict, deg_map)
        vals = np.linalg.eigvalsh(Hk)
        eigs[i, :] = np.sort(vals.real - fer)


    plt.figure(figsize=(9,6))
    for band in range(num_wann):
        plt.plot(kdist, eigs[:, band], linewidth=1.0)
    tick_pos = [kdist[idx] for idx in label_positions]
    plt.xticks(tick_pos, labels_seq, rotation=0)
    for tp in tick_pos:
        plt.axvline(tp, color='0.6', linestyle=':', linewidth=0.6)
    plt.ylabel("Energy (eV)")
    plt.title(f"Band structure of hBN")
    plt.tight_layout()
    plt.show()

if __name__ == "__main__":
    main()